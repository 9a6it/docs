{% raw %}

## Vue

- [Что такое Vue?](#что-такое-vue--)
- [Быстрый старт с Vue 3](#быстрый-старт-с-vue-3--)
- [Создание приложения](#создание-приложения--)
- [Синтаксис шаблона](#синтаксис-шаблона--)

### Что такое Vue? | [▲](#vue)

Vue (произносится /vjuː/, как view) - это JS-фреймворк для создания пользовательских интерфейсов. Он построен поверх стандартных HTML, CSS и JS и предоставляет декларативную и компонентно-ориентированную модель программирования, которая помогает эффективно разрабатывать пользовательские интерфейсы, будь они простыми или сложными.

Вот простейший пример:

```
import { createApp } from 'vue'

createApp({
  data() {
    return {
      count: 0
    }
  }
}).mount('#app')
```
```
<div id="app">
  <button @click="count++">Count is: {{ count }}</button>
</div>
```

Приведенный выше пример демонстрирует две основные особенности Vue:

- **Декларативный рендеринг**: Vue расширяет стандартный HTML с помощью синтаксиса шаблона, который позволяет нам декларативно описывать вывод HTML на основе состояния JS.
- **Реактивность**: Vue автоматически отслеживает изменения состояния JS и эффективно обновляет DOM, когда происходят изменения.

Возможно, у вас уже есть вопросы - не волнуйтесь. Мы рассмотрим все мельчайшие детали в остальной части документации. Читайте дальше, чтобы иметь представление о том, что предлагает Vue на высоком уровне.

*Остальная документация предполагает базовое знакомство с HTML, CSS и JS. Если вы совершенно новичок во фронтенде, возможно, не лучшая идея сразу переходить к фреймворку в качестве первого шага - изучите основы, а затем возвращайтесь! Предыдущий опыт работы с другими фреймворками помогает, но не обязателен.*

#### Прогрессивный фреймворк

Vue - это фреймворк и экосистема, которая охватывает большинство общих функций, необходимых при разработке внешнего интерфейса. Но веб чрезвычайно разнообразен - то, что мы создаем в интернете, может сильно различаться по форме и масштабу. Имея это в виду, Vue разработан таким образом, чтобы быть гибким и адаптируемым. В зависимости от вашего варианта использования Vue можно использовать по-разному:

- Улучшение и оживление статического HTML без этапа сборки.
- Встраивание в виде веб-компонентов на любую страницу.
- Одностраничное приложение (SPA).
- Полный стек / рендеринг на стороне сервера (SSR).
- Jamstack / Генератор статических сайтов (SSG).
- Ориентирование на пк, мобильные устройства, WebGL и даже терминал.

Если вы находите эти термины пугающими, не волнуйтесь! Документация требует только базовых знаний HTML и JS, и вы должны быть в состоянии понимать материал, не будучи экспертом в фронтенде.

Если вы опытный разработчик, заинтересованный в том, как наилучшим образом интегрировать Vue в свой стек, или вам интересно, что означают эти термины, мы обсудим их более подробно в разделе Способы использования Vue.

Несмотря на гибкость, основные знания о том, как работает Vue, являются общими для всех этих вариантов использования. Даже если сейчас вы всего лишь новичок, знания, полученные на этом пути, останутся полезными по мере того, как вы будете расти и достигать более амбициозных целей в будущем. Если вы опытный разработчик, вы можете выбрать оптимальный способ использования Vue в зависимости от проблем, которые вы пытаетесь решить, сохраняя при этом ту же производительность. Вот почему мы называем Vue "Прогрессивным фреймворком" - это платформа, которая может расти вместе с вами и адаптироваться к вашим потребностям.

#### Однофайловые компоненты (SFC - single-file components)

В большинстве проектов Vue с поддержкой инструментов сборки мы создаем компоненты Vue, используя формат файла, подобный HTML, называемый Single-File Component (также известный как *.vue files, сокращенно SFC). Vue SFC, как следует из названия, инкапсулирует логику компонента (JS), шаблон (HTML) и стили (CSS) в одном файле. Вот предыдущий пример, написанный в формате SFC:

```
<script>
export default {
  data() {
    return {
      count: 0
    }
  }
}
</script>

<template>
  <button @click="count++">Count is: {{ count }}</button>
</template>

<style scoped>
button {
  font-weight: bold;
}
</style>
```

SFC является определяющей функцией Vue и рекомендуемым способом создания компонентов Vue, если ваш вариант использования требует настройки сборки. Вы можете узнать больше о том, как и почему работает SFC, в специальном разделе, но пока просто знайте, что Vue выполнит все настройки инструментов сборки за вас.

#### Стили API

Компоненты Vue могут быть созданы в двух различных стилях API: Options API и Composition API.

#### Options API

С помощью Options API мы определяем логику компонента, используя объект опций, таких как `data`, `methods` и `mounted`. Свойства, определенные с помощью опций, отображаются в `this`, который указывает на экземпляр компонента:

```
<script>
export default {
  // Свойства, возвращенные из data() становятся реактивным состоянием и будут доступны через `this`
  data() {
    return {
      count: 0
    }
  },

  // Методы - это функции, которые мутируют состояние и вызывают обновления
  // Их можно привязывать как обработчики событий в шаблоне
  methods: {
    increment() {
      this.count++
    }
  },

  // Хуки жизненного цикла вызывается на различных этапах жизни компонента
  // Эта функция будет вызвана когда компонент вмонтирован
  mounted() {
    console.log(`The initial count is ${this.count}.`)
  }
}
</script>

<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>
```

#### Composition API

С помощью Composition API мы определяем логику компонента, используя импортированные функции API. В SFC Composition API обычно используется через `<script setup>`. Атрибут setup - это подсказка, которая заставляет Vue выполнять преобразования во время компиляции, которые позволяют нам использовать Composition API с меньшим количеством настроек. Например, импорт и переменные / функции верхнего уровня, объявленные в `<script setup>`, можно использовать непосредственно в шаблоне.

```
<script setup>
import { ref, onMounted } from 'vue'

// Реактивный стейт
const count = ref(0)

// Функции, которые мутируют стейт и триггерят обновления
const increment = () => {
  count.value++
}

// Хуки жизненного цикла
onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>

<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>
```

#### Какой способ выбрать?

Оба стиля API полностью способны охватывать распространенные варианты использования. Это разные интерфейсы, работающие на базе одной и той же базовой системы. Фактически, Options API реализован поверх Composition API! Фундаментальные концепции и знания о Vue являются общими для обоих стилей.

Options API сосредоточен вокруг концепции "экземпляра компонента" (`this` как видно из примера), которая обычно лучше согласуется с ментальной моделью на основе классов для пользователей, изучающих ООП. Это также более удобно для начинающих, поскольку абстрагируется от деталей реактивности и обеспечивает организацию кода с помощью групп опций.

Composition API сосредоточен на объявлении реактивных переменных непосредственно в области видимости функции и составлении состояния из нескольких функций вместе, чтобы справиться со сложностью. Это более свободная форма, и для эффективного использования требуется понимание того, как работает реактивность во Vue. В свою очередь, его гибкость обеспечивает более мощные шаблоны для организации и повторного использования логики.

Вы можете узнать больше о сравнении двух стилей и потенциальных преимуществах Composition API в разделе Часто задаваемые вопросы по Composition API.

Если вы новичок во Vue, вот наша общая рекомендация:

- В учебных целях выбирайте тот стиль, который кажется вам более понятным. Опять же, большинство основных концепций являются общими для этих двух стилей. Вы всегда можете перейти на другой стиль позже.

Для продакшен использования:

- Выбирайте Options API, если вы не используете инструменты сборки или планируете использовать Vue в основном в сценариях низкой сложности, например, прогрессивное улучшение.
- Используйте Composition API + однофайловые компоненты, если вы планируете создавать полноценные приложения с помощью Vue с большим количеством логики.

Вам не обязательно придерживаться только одного стиля на этапе обучения. В остальной документации будут представлены примеры кода в обоих стилях, где это применимо.

### Быстрый старт с Vue 3 | [▲](#vue)

*Для создания Vue3-приложения вам потребуются базовые навыки работы с консолью, а также Node.js версии 16.0 или выше.*

#### Создание проекта через консоль

В этом разделе мы расскажем, как создать SPA Vue приложение на вашем локальном компьютере. Созданный проект будет использовать настройку сборки, основанную на Vite, и позволит нам использовать однофайловые компоненты Vue (SFC).

Убедитесь, что у вас установлена версия Node.js хотя бы 16.0, затем запустите следующую команду в командной строке:

```
npm init vue@latest
```

Эта команда установит и выполнит `create-vue`, официальный инструмент для развертывания проектов на Vue. Вам будут показаны диалоги для нескольких дополнительных опций, таких как TypeScript и поддержка тестирования.

Как только проект будет создан, следуйте инструкциям по установке зависимостей и запуску сервера для разработки:

```
cd <имя-проекта>
npm install
npm run dev
```

Теперь у вас запущен ваш проект на Vue! Обратите внимание, что примеры компонентов в сгенерированном проекте написаны с использованием Composition API и `<script setup>`, а не Options API. Вот несколько доп советов:

- Рекомендуемая IDE для работы - Visual Studio Code. Если вы используете другие редакторы, ознакомьтесь с разделом поддержки IDE.
- Более подробная информация об инструментах, включая интеграцию с серверными фреймворками, обсуждается в руководстве по инструментам.
- Чтобы узнать больше о базовом инструменте сборки Vite, ознакомьтесь с документацией Vite.
- Если вы решите использовать TypeScript, ознакомьтесь с руководством по использованию TypeScript.

Когда вы будете готовы отправить свое приложение в продакшен, выполните следующую команду:

```
npm run build
```

Это создаст готовую к продакшену сборку вашего приложения в каталоге `./dist`. Ознакомьтесь с руководством по развертыванию в продакшн среду, чтобы узнать больше о настройке вашего приложения для продакшена.

#### Использование Vue из CDN

Вы можете использовать Vue непосредственно из CDN с помощью тега script:

```
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```

Здесь мы используем unpkg, но вы также можете использовать любой другой CDN, который обслуживает пакеты npm, например jsdelivr или cdnjs. Конечно, вы также можете скачать этот файл и использовать его самостоятельно.

При использовании Vue из CDN "этап сборки" не требуется. Это значительно упрощает настройку и подходит для оживления статического HTML или интеграции с сервером. Однако вы не сможете использовать синтаксис однофайлового компонента (SFC).

#### Использование глобального билда

Приведенная выше ссылка загружает глобальную сборку Vue, где все API верхнего уровня отображаются как свойства глобального объекта Vue. Вот полный пример использования глобального билда:

```
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

<div id="app">{{ message }}</div>

<script>
  const { createApp } = Vue

  createApp({
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }).mount('#app')
</script>
```

#### Использование ES Module билда

В документации мы будем в основном использовать синтаксис ES модулей. Большинство современных браузеров уже поддерживают ES-модули, поэтому мы можем использовать Vue из CDN как ES-модуль, подобный этому:

```
<div id="app">{{ message }}</div>

<script type="module">
  import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

  createApp({
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }).mount('#app')
</script>
```

Обратите внимание, что мы используем `<script type="module">`, а импортированный URL для CDN указывает на сборку ES modules для Vue.

#### Включение карт импорта

В приведенном выше примере мы импортируем из полного URL-адреса CDN, но в остальной документации вы увидите код, подобный этому:

```
import { createApp } from 'vue'
```

Мы можем указать браузеру, где искать импорт vue, используя карты импорта:

```
<script type="importmap">
  {
    "imports": {
      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
    }
  }
</script>

<div id="app">{{ message }}</div>

<script type="module">
  import { createApp } from 'vue'

  createApp({
    data() {
      return {
        message: 'Hello Vue!'
      }
    }
  }).mount('#app')
</script>
```

Вы также можете добавить записи для других зависимостей в карту импорта, но убедитесь, что они указывают на версию ES модулей для библиотеки, которую вы собираетесь использовать.

*Импорт карт поддерживается по умолчанию в браузерах на базе Chromium, поэтому мы рекомендуем использовать Chrome или Edge в процессе обучения.*

#### Разделение модулей

По мере углубления в руководство нам, возможно, потребуется разделить наш код на отдельные файлы JS, чтобы ими было легче управлять. Например:

index.html
```
<div id="app"></div>

<script type="module">
  import { createApp } from 'vue'
  import Component from './component.js'

  createApp(Component).mount('#app')
</script>
```

component.js
```
export default {
  data() {
    return { count: 0 }
  },
  template: `<div>Count is: {{ count }}</div>`
}
```

Если вы непосредственно откроете вышеуказанный index.html в вашем браузере вы обнаружите, что он выдает ошибку, поскольку ES модули не могут работать по протоколу `file://`. Для того чтобы это сработало, вам нужно обслуживать index.html по протоколу `http://`, с локальным HTTP-сервером.

Чтобы запустить локальный HTTP-сервер, сначала установите Node.js а затем запустите команду `npx serve` из командной строки в том же каталоге, где находится ваш HTML-файл. Вы также можете использовать любой другой HTTP-сервер, который может обслуживать статические файлы с правильными MIME-типами.

Возможно, вы заметили, что шаблон импортированного компонента встроен в виде JS-строки. Если вы используете Visual Studio Code, вы можете установить расширение `es6-string-html` и добавить к строкам префикс-комментарий `/*html*`, чтобы получить подсветку синтаксиса для них.

#### Использование Composition API без сборки

Во многих примерах для Composition API будет использоваться синтаксис `<script setup>`. Если вы собираетесь использовать Composition API без этапа сборки, ознакомьтесь с использованием опции `setup()`.

### Создание приложения | [▲](#vue)

Каждое приложение Vue начинается с создания нового экземпляра приложения с помощью функции `createApp`:

```
import { createApp } from 'vue'

const app = createApp({
  // Опции корневого компонента
})
```

#### Опции корневого компонента

Объект, который мы передаем в createApp, на самом деле является компонентом. Каждому приложению требуется "корневой компонент", который может содержать другие компоненты в качестве своих дочерних элементов.

Если вы используете однофайловые компоненты (SFC), мы обычно импортируем корневой компонент из другого файла:

```
import { createApp } from 'vue'
// Импортируем корневой компонент из файла SFC-компонента
import App from './App.vue'

const app = createApp(App)
```

Хотя во многих примерах в этой документации требуется только один компонент, большинство реальных приложений организованы в виде дерева вложенных, повторно используемых компонентов. Например, дерево компонентов приложения Todo (список задач) может выглядеть следующим образом:

```
App (root component)
├─ TodoList
│  └─ TodoItem
│     ├─ TodoDeleteButton
│     └─ TodoEditButton
└─ TodoFooter
   ├─ TodoClearButton
   └─ TodoStatistics
```

В последующих разделах руководства мы обсудим, как определить и скомпоновать несколько компонентов вместе. Перед этим мы сосредоточимся на том, что происходит внутри одного конкретного компонента.

#### Встраивание приложения

Экземпляр приложения ничего не будет рендерить до тех пор, пока не будет вызван его метод `.mount()`. Он ожидает аргумент "container", который может быть либо фактическим элементом DOM, либо строкой селектора:

```
<div id="app"></div>
```
```
app.mount('#app')
```

Содержимое корневого компонента приложения будет отображаться внутри элемента контейнера. Сам элемент-контейнер не считается частью приложения.

Метод `.mount()` всегда следует вызывать после завершения всех конфигураций приложения и регистрации ресурсов. Также обратите внимание, что его возвращаемым значением, в отличие от методов регистрации активов, является экземпляр корневого компонента, а не экземпляр приложения.

#### Шаблон корневого компонента внутри DOM

Шаблон для корневого компонента обычно является частью самого компонента, но также возможно предоставить шаблон отдельно, записав его непосредственно внутри контейнера для встраивания:

```
<div id="app">
  <button @click="count++">{{ count }}</button>
</div>
```
```
import { createApp } from 'vue'

const app = createApp({
  data() {
    return {
      count: 0
    }
  }
})

app.mount('#app')
```

Vue автоматически будет использовать `innerHTML` контейнера в качестве шаблона, если у корневого компонента нет опции template.

*Шаблоны In-DOM часто используются в приложениях, которые используют Vue без этапа сборки. Они также могут использоваться в сочетании с серверными фреймворками, где корневой шаблон может генерироваться сервером динамически.*

#### Настройки приложения

Экземпляр app предоставляет объект `.config`, который позволяет нам настроить несколько параметров на уровне приложения, например, определить обработчик ошибок на уровне приложения, который фиксирует ошибки от всех дочерних компонентов:

```
app.config.errorHandler = (err) => {
  // Обработка ошибки
}
```

Экземпляр app также предоставляет несколько методов для регистрации ресурсов, относящихся к области приложения. Например, регистрация компонента:

```
app.component('TodoDeleteButton', TodoDeleteButton)
```

Это делает компонент TodoDeleteButton доступным для использования в любом месте нашего приложения (так называемая глобальная регистрация компонента). Мы обсудим регистрацию компонентов и других типов активов в последующих разделах руководства. Вы также можете просмотреть полный список API-интерфейсов экземпляра приложения в его API ссылке.

Обязательно примените все конфигурации приложения перед монтированием в контейнер!

#### Несколько экземпляров приложения

Вы не ограничены одним экземпляром приложения на одной странице. API `createApp` позволяет нескольким Vue приложениям сосуществовать на одной странице, каждое со своей собственной областью видимости, настройками и глобальными ресурсами:

```
const app1 = createApp({
  // ...
})
app1.mount('#container-1')

const app2 = createApp({
  // ...
})
app2.mount('#container-2')
```

Если вы используете Vue для улучшения и оживления HTML-кода, отображаемого сервером, и вам нужен Vue только для управления определенными частями большой страницы, избегайте установки одного экземпляра приложения Vue для всей страницы. Вместо этого создайте несколько небольших экземпляров приложения и смонтируйте их на элементах, за которые они отвечают.

### Синтаксис шаблона | [▲](#vue)

Vue использует синтаксис шаблона на основе HTML, который позволяет вам декларативно привязывать отображаемый DOM к данным базового экземпляра компонента. Все шаблоны Vue представляют собой синтаксически валидный HTML, который может быть проанализирован браузерами, совместимыми со спецификациями, и HTML-анализаторами.

*Под капотом Vue компилирует шаблоны в высокооптимизированный JS-код. В сочетании с системой реактивности Vue может разумно определить минимальное количество компонентов для повторного рендеринга и применить минимальное количество манипуляций с DOM при изменении состояния приложения.*

Если вы знакомы с концепциями виртуального DOM и предпочитаете нативную мощь JS, вы также можете напрямую писать функции рендеринга вместо шаблонов (с дополнительной поддержкой JSX). Однако обратите внимание, что они не обладают таким же уровнем оптимизации во время компиляции, как шаблоны.

#### Интерполяция текста

Наиболее простой формой привязки данных является интерполяция текста с использованием синтаксиса "усов" (двойные фигурные скобки).:

```
<span>Message: {{ msg }}</span>
```

"Усы" (двойные фигурные скобки) будут заменены значением свойства `msg` из соответствующего экземпляра компонента. Значение также будет обновляться всякий раз, когда изменяется свойство `msg`.

#### Сырой HTML

Двойные фигурные скобки интерпретируют данные как обычный текст, а не HTML. Чтобы вывести реальный HTML, вам нужно использовать директиву `v-html`:

```
<p><span v-html="rawHtml"></span></p>
```

Здесь мы сталкиваемся с чем-то новым. Атрибут `v-html`, который вы видите, называется директивой. Директивы имеют префикс v-, чтобы указать, что они являются специальными атрибутами, предоставляемыми Vue, и, как вы, возможно, догадались, они применяют особое реактивное поведение к отображаемому DOM. Здесь мы, по сути, говорим: "обновляйте `innerHTML` этого элемента с помощью свойства `rawHtml` в текущем активном экземпляре".

Содержимое `span` будет заменено значением свойства `rawHtml`, интерпретируемого как обычный HTML - привязки данных (если есть) игнорируются. Обратите внимание, что вы не можете использовать `v-html` для создания частичных элементов шаблона, поскольку Vue не является шаблонизатором на основе строк. Вместо этого предпочтение отдается компонентам как основной единице для повторного использования в пользовательском интерфейсе и его композиции.

*Динамический рендеринг произвольного HTML-кода на вашем веб-сайте может быть очень опасным, поскольку это может легко привести к уязвимостям XSS. Используйте v-html только для проверенного контента и никогда для контента, предоставленного пользователем.*

#### Привязка атрибутов

Двойные фигурные скобки не могут быть использованы внутри значений атрибутов. Вместо этого используйте директиву `v-bind`:

```
<div v-bind:id="dynamicId"></div>
```

Директива `v-bind` предписывает Vue синхронизировать атрибут id элемента со свойством `dynamicId` компонента. Если привязанное значение равно `null` или "не определено" (`undefined`), то атрибут будет удален из отображаемого элемента.

#### Короткий ярлык для v-bind

Поскольку директива `v-bind` является практически самой популярной во Vue, для нее выделен специальный сокращенный синтаксис - достаточно поставить двоеточие перед атрибутом.

```
<div :id="dynamicId"></div>
```

Атрибуты, начинающиеся с ":" могут немного отличаться от обычного HTML, но на самом деле это допустимый символ для имен атрибутов, и все браузеры, поддерживаемые Vue, могут правильно его парсить. Кроме того, они не отображаются в окончательной отрисованной разметке. Сокращенный синтаксис необязателен, но вы, вероятно, оцените его по достоинству, когда позже узнаете больше о его использовании. В реальных проектах очень редко можно увидеть `v-bind`, но сплошь и рядом используется сокращенный синтаксис.

В остальной части руководства мы будем использовать сокращенный синтаксис в примерах кода, поскольку это наиболее распространенное использование разработчиками Vue.

#### Логические атрибуты

Логические атрибуты - это атрибуты, которые могут указывать на значения `true` / `false` по их присутствию в элементе. Например, `disabled` является одним из наиболее часто используемых логических атрибутов. В случае с такими атрибутами `v-bind` работает немного по-другому:

```
<button :disabled="isButtonDisabled">Button</button>
```

Атрибут `disabled` будет включен, если `isButtonDisabled` имеет истинное значение. Он также будет включен, если значение является пустой строкой, сохраняя согласованность с `<button disabled="">`. Для других ложных значений атрибут будет опущен.

#### Динамическая привязка множества атрибутов

Если у вас есть объект JS, представляющий несколько атрибутов, который выглядит следующим образом:

```
data() {
  return {
    objOfAttrs: {
      id: 'container',
      class: 'wrapper'
    }
  }
}
```

Вы можете привязать их к одному элементу, используя `v-bind` без аргумента:

```
<div v-bind="objOfAttrs"></div>
```

#### Использование JS-выражений

До сих пор мы привязывались только к простым ключам свойств в наших шаблонах. Но Vue на самом деле поддерживает всю мощь JS-выражений внутри всех привязок данных. Это позволяет вычислять нужные ключи и атрибуты динамически:

```
{{ number + 1 }}

{{ isOk ? 'Yes' : 'Np' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

Эти выражения будут вычислены как JS код в области видимости данных для текущего экземпляра компонента.

В шаблонах Vue JS-выражения могут использоваться в следующих позициях:

- Интерполяции внутри текста (усы, то есть двойные фигурные скобки).
- В значении атрибута любых директив Vue (специальные атрибуты, начинающиеся с v-).

#### Только выражения

Каждая привязка может содержать только одно единственное выражение. Выражение - это фрагмент кода, который может быть вычислен до значения. Простой способ проверить на выражение заключается в том, можно ли его использовать после ключевого слова `return` - если да, то это выражение.

Следовательно, следующие примеры не будут работать:

```
<!-- Это определение, а не выражение -->
{{ var a = 1 }}

<!-- Также не работает - для такого можно использовать тернарные операторы -->
{{ if (isOk) { return message } }}
```

#### Вызов функций

Можно вызвать метод, предоставляемый компоненту, внутри выражения привязки:

```
<span :title="toTitleDate(date)">
  {{ formatDate(date) }}
</span>
```

Функции, вызываемые внутри выражений привязки в шаблоне, будут вызываться каждый раз при обновлении компонента, поэтому у них не должно быть никаких побочных эффектов, таких как изменение данных или запуск асинхронных операций.

#### Ограниченный глобальный доступ

Выражения в шаблоне изолированы и имеют доступ только к ограниченному списку глобальных свойств. В списке представлены часто используемые встроенные глобальные переменные, такие как `Math` и `Date`.

Глобальные переменные, явно не включенные в список, например, пользовательские свойства в `window` не будут доступны в выражениях шаблона. Однако вы можете явно определить дополнительные глобальные переменные для всех выражений Vue, добавив их в `app.config.globalProperties`.

{% endraw %}
